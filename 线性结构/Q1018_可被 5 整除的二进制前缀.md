给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。

返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。



```
输入：[0,1,1]
输出：[true,false,false]
解释：
输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。
```



思路1（模拟）：

遍历给定数组，并构建对应的二进制数值，然后判断能否被5整除即可。考虑到给定数组长度非常大，因此我们不能保存完整的数值，每次只需保留其余数即可，整数部分不论是否相加并不影响后面数值的判断。

```c++
vector<bool> prefixesDivBy5(vector<int>& A) {
        //逐位遍历，生成对应数值，并对5求余判断
        int len = A.size(),temp = 0;
        vector<bool> ans(len,false);

        for( int i = 0 ; i < len; ++i){
            temp |= A[i];
            temp %= 5;
            ans[i] = temp == 0 ? true:false;
            temp <<= 1;
        }
        return ans;
    }
```

<b>复杂度分析：</b>

时间复杂度：$ O(n) $

空间复杂度：$O(1) $



note（引用）：

这题其实涉及比较基础的数学知识——模运算法则，即除了除法外，几乎常见的运算都符合某种类似分配律的运算律：

```
1. (a + b) % p = (a % p + b % p) % p 
2. (a - b) % p = (a % p - b % p) % p 
3. (a * b) % p = (a % p * b % p) % p 
4. (a^b) % p = ((a % p)^b) % p
```

题解已经隐含了1和3的证明，剩下两个的证明也十分类似。本题的推演实际涉及加法和乘法（1和3），我们简化一下，假设我们想求2^n对5的模（即2^n % 5），如果n很大，我们是无法通过计算出2^n，再去取模的。那么依律3，我们可以先算r = (2^n-1) % 5，再将结果r带入(r * 2) % 5；那么如何计算r呢，已经发现了吧——递归（递归（递归）...）。甚至依律3，我们还可以对2^n进行2^(n/2) * 2^(n/2)这样的拆分，以此实现类似快速幂的求模方式。

类似的求模技巧虽然很简单，但是作为某些难题的组成部分，经常是容易被忽视的，比如律1律3经常用在字符串匹配的rolling-hash算法当中，想计算一个整形的hash值，而小写文字有26种可能取值，指数幂26^n很容易就会超过值域，即便是长整形也需要不断取模才能使得hash值有意义——当我们忽略碰撞，模空间内的值就会成为可靠的校验依据。



参考链接： https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/solution/ke-bei-5-zheng-chu-de-er-jin-zhi-qian-zh-asih/

