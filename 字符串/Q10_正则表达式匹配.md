给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。



思路：（动态规划）

匹配两个字符串，逐一对位比较即可。但由于正则表达式的存在，p中c* 这样的组合能够匹配s中任意多个字符串，使得匹配方案多样，因此考虑使用动态规划，记录下我们之前匹配的各种方案的结果，即枚举所有匹配形式。我们定义 $ dp[i][j] : $ s中的前i个字符串与p中的前j个字符串的匹配结果(true or false)。那么显然，枚举所有的方案共需要 $ m*n $ 的空间。现在我们来分析匹配的各种情况。

1.若 p[j] 是一个小写字符，那么只有当前指向的两个字符相同时，他们才有匹配的可能，匹配成功还需要它们之前的字符也匹配。
$$
dp[i][j]  = 
 \begin{cases}
 dp[i-1][j-1]  & s[i] = p[j] \\
 false & otherwise
 \end{cases}
$$
2.若 $p[j] = '*' $ , 那么我们需要与$p[j-1]$ 组合，它可以匹配0个或任意多个p[j-1]字符。那么此时 将组合与s[i]比较时有下面两种情况：

- $  p[j-1] = s[i] $ ，即组合可以成功匹配s当前指向的字符，但p中的当前组合由于可以匹配0或任意多个相同字符，因此存在两种可能。

  1.第一种是选择匹配，那么该组合还可以继续使用，用于比较s之后的字符串。因此，当前字符匹配成功后，由于还需要获取之前的子串是否匹配成功（已经计算）。在我们获取它们之前的子串是否匹配成功时就有两种可能，s的上一个字符同样用该组合匹配过($ dp[i][j] = dp[i-1][j] $)，还有一种就是之前未使用该组合匹配过,那么他们之前比较的状态应当是 $ dp[i-1][j-1] $ ,但由于$[j-1,j]$ 是一个组合，因此可以看作为一次匹配，即一定使用该组合至少匹配一次。如下面的示例：

  ```
    i
  abbc
    j
  ab*c 
  ```

  当前 $ dp[i][j] $ 符合上面情况，且该组合是第一次匹配，上次匹配应当是 s[i-1] 和 p[j-1]匹配，而这个匹配同样可以用 s[i-1] 和 p[j-1] + p[j] 去完成，即看作为使用组合匹配 $  dp[i][j] = dp[i-1][j-1] = dp[i-1][j]  $ 。

  2.第二种情况则是虽然可以使用组合匹配，但是我们不选择匹配，即匹配0次。则直接丢弃该组合，停止匹配。 $   dp[i][j] = dp[i][j-2] $ 。

  综上所述，$ p[j] = '*'  $ 时有（符合一项即可）：
  $$
  dp[i][j]  = 
   dp[i-1][j] \ \ \ or \ \ \  dp[i][j-2]
  $$
  

- $  p[j-1] \neq s[i] $ ,则组合未能成功匹配s当前指向的字符，则直接去掉该组合（组合0次匹配），不再进行匹配。此时 $ dp[i][j] $ 不能算匹配成功，即当前第i个字符串仍需去比较，需向后遍历p字符串与当前s指向的第i个字符比较（即由$ dp[i][j+1] $ 去判断）。因此当前$ dp[i][j] $ 结果应为（停止与该组合比较，比较结果为false）：
  $$
  dp[i][j]  =  dp[i][j-2]
  $$

综合以上情况，最终的状态转移方程应该为：
$$
dp[i][j]  = 
 \begin{cases}
 if \ p[j] \neq '*' = 
 			\begin{cases}
 				dp[i-1][j-1]  & s[i] = p[j]\ || \ p[j] = '.' \\
 				false & otherwise
 			\end{cases}
 \\
 otherwise = 
  			\begin{cases}
 				dp[i-1][j] \ \ \ or \ \ \  dp[i][j-2]  & s[i] = p[j-1] \\
 				dp[i][j-2] & otherwise 
 			\end{cases}
 			
 \end{cases}
$$


```c++
bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();

        auto matches = [&](int i, int j) {
            if (i == 0) return false;  //空串s与非空串p比较直接返回false
            if (p[j - 1] == '.') return true;
            return s[i - 1] == p[j - 1];
        };

        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        dp[0][0] = true;
        for (int i = 0; i <= m; ++i) { //i,j代表前i,j个字符串,下标从1开始
            for (int j = 1; j <= n; ++j) {
                if( p[j-1] == '*'){ //判断当前指向字符下标从0开始，需减1
                    dp[i][j] |= dp[i][j-2];
                    if(matches(i,j-1)) dp[i][j] |= dp[i-1][j]; //需比较组合的第一个字符
                }else{
                    if(matches(i,j)) dp[i][j] |= dp[i-1][j-1];
                }
            }
        }
        return dp[m][n];
    }
```

<b>复杂度分析</b>

时间复杂度：$ O(mn)$ 。

空间复杂度：$ O(mn)$ 。 

