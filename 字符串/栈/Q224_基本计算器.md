实现一个基本的计算器来计算一个简单的字符串表达式 `s` 的值。

```
输入：s = "1 + 1"
输出：2
```

- `1 <= s.length <= 3 * 105`
- `s` 由数字、`'+'`、`'-'`、`'('`、`')'`、和 `' '` 组成
- `s` 表示一个有效的表达式



思路一：栈操作

由于表达式中只包含了括号和加减法，那么去括号只需要考虑数字前面的符号是否改变即可。因此我们可以考虑将表达式去括号然后进行运算，顺序遍历元素，若左括号之前是正号，那么我们直接去掉括号进行运算;若左括号之前是负号，那么括号中的每个数字前的正负都应该翻转,然后再进行运算。

我们用一个栈来保存遇到左括号前的符号（$1or-1$） ， 并结合一个变量$sign= \{1.-1\}$  来进行运算，即决定是否翻转当前符号再运算。具体做法为：

1. 初始化栈顶元素为1,表示开始时没有括号，我们顺序遍历表达式，符号也不需要改变，正常加减顺序运算既可。
2. 当遇到左括号时，我们将当前sign（即左括号之前的运算符，决定了括号内符号的变化）压入栈中，直到遇到右括号的过程之前，我们都使用该栈顶元素（括号前的运算符）配合括号中的运算符更新sign，从而计算当前括号中的内容，遇到右括号时，将栈顶元素弹出即可。

```
 -(1+2-3)  
 1.遇到左括号时，sign = -1（前面为负号）,于是将sign = -1压入栈中
 2.继续顺序遍历元素，遇到右括号之前，我们都结合当前栈顶元素 top = -1 和遍历到的符号进行运算
 遍历元素			操作       
  1 	   ret += sign*1 = -1
  +		   sign = top = -1;  (当前运算符是正号，不影响翻转，所以正负由top决定，即括号前的符号)
  2        ret += sign*2 = -1-2 = -3
  - 	   sign = -top = 1;	(当前运算符与括号前运算符共同作用，使符号翻转)
  3		   ret += sign*3 = -3+3 = 0
```



```c++
int calculate(string s) {
        int sign = 1, len = s.size(),i = 0,ans = 0;
        stack<int> stk;
        
        stk.push(1); //初始化栈顶元素
        while( i < len ){
            if( s[i] == ' ' ) i++;
            else if( s[i] == '+' ){
                sign = stk.top();
                i++;
            }
            else if( s[i] == '-' ){
                sign = -stk.top();
                i++;
            }
            else if( s[i] == '(' ){
                stk.push(sign);
                i++;
            }
            else if( s[i] == ')' ){
                stk.pop();
                i++;
            }
            else{
                int num = 0;
                while( i <  len && s[i] >= '0' && s[i] <= '9'){
                    num = num*10 + (s[i] - '0');
                    i++;
                }
                ans += sign*num;
            }
        }
        return ans;
    }
```



<b>复杂度分析</b>

时间复杂度：$ O(s)$ ，s为给定字符串的长度。

空间复杂度：$O(s)$ 。