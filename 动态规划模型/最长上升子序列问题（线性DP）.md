状态表示:$ f[i] $ 



集合：所有以$ a[i] $ 结尾的严格单调上升子序列

属性： Max、Min、数量 



状态计算：所有以$a[i]$ 结尾的上升子序列的集合，上一状态可能为以$ a[0] ... a[i-1] $ 结尾的子序列，还有一个状态只包含$a[i]$，即商议状态为空 。



note: 求解全局最值时，状态划分区间可以重复，因为当前状态一定是由上次的某一个状态转换而来，而不是同时由两个状态累加再转换，因此只要不遗漏任何状态即可。





问题1：最长公共上升子序列问题：

是最长公共子序列+最长上升子序列问题的结合。其中最长公共子序列通过$ dp[i,j] $ 表示：所有由$ s[0...i] $ 和 $ s_2[0...j] $ 构成的最长公共子序列，最长上升子序列问题通过$ dp[i] $ 表示 以$s[i]$ 结尾的最长上升子序列的长度。

因此设$ dp[i,j] $ 表示所有由$ s[0...i] $ 和 $ s_2[0...j] $ 构成，且以$ s_2[j] $ 结尾的最长公共上升子序列。

状态划分：先将$ dp[i][j] $ 划分为末尾包含$ a[i] $ 和不包含$ a[i] $ 两部分。（思考起点类似于最长公共子序列的状态划分，但此时提前加了限制以$ b[j] $ 结尾的条件，因此少了两个状态）

- 若不包含$ a[i] $ ，则$ dp[i,j] = dp[i-1,j]$ 。
-  若包含$ a[i] $ ，那么s必然以$a[i]$ 结尾，此时有$ a[i] = b[j] $ ，我们需要进一步的将该区间划分：将该区间按照最长上升子序列问题划分，所有以$ b[j] $ 结尾且另一字符串包含$a[i]$ 问题，其中以$ b[j] $ 结尾的上一状态为以$ b[0...j-1] $ 任意元素结尾的所有上升子序列的集合。因此有：

$$
dp[i][j] = max(dp[i,k]+1)     \ \ \ k < i
$$

