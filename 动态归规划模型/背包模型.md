dp表示：

dp表示一般为$dp[i][j]$ ,其中i为选择前i个物品，j为限制条件。 

状态转移：

思考如何将$dp[i][j]$ 划分为不同的集合，且划分的集合不重复也不遗漏所有情况。 





多重背包模型的二进制优化：选择指定次数的物品最大为 s次,若s较大（例如有1000个物品，对应2000种价值，此时时间复杂度为$1000*2000*s$），容易超时，因此我们将s用二进制表示，例如：

$  1 <= s <= 2000$ ，那么我们可以用$ \lceil log2000 \rceil = 11 $ 个数来表示 $0-2000$ 。

```
1 2 4 8 16 32 64 128 256 512 977 (最后一个数由2000减去前面的累加和所得)
1 能表示 1
[1 2] 能表示 1-3
[1 2 4] 能表示 1-7
....
[1 2 4 8 16 32 64 128 256 512] 能表示 1-1023
[1 2 4 8 16 32 64 128 256 512 977] 能表示 1-2000
```

具体的，若体积为 w，价值为 v，并且可以选择s次的单个物品，我们可以将这单个物品转换为 $logs$ 个物品表示，且转换后的每个物品只能选择1次，通过01背包选择组合，就可以表示之前单个物品选择s次。

例如：体积为 2,价值为5,可以选择1000次，那么有：$ logs = \lceil log1000 \rceil= 10 $ ,则可以用下面10个物品的01背包选择来表示前面的1000中选择。

```
拆分后物品基数i		1 2 4 8 16 32 64 128 256 488
体积V(v*i)	       2 4 8 16 32 64 128 256 512 976
价值W(w*i)		   5 10 20 40 80 160 320 640 1280 2440
```

对N个物品，每个物品可以选择$s$ 次，那么我们拆分后物品变为 $ N*logs $ 个，每个物品可以选择1次，这样就能变为0,1背包问题，也降低了时间复杂度。

```
const int N = 25000;

	int w[N],v[N];
    int k = 1,cnt = 0,n= 0;
    int a = 5,b = 5,s = 10;
    while( k <= s ){
        cnt++;
        v[cnt] = a*k;
        w[cnt] = b*k;
        cout << s << endl;
        s -= k;
        k *= 2;
    }
    if( s > 0 ){
        cnt++;
        v[cnt] = a*s;
        cout << s << endl;
        w[cnt] = b*s;
    }

    n = cnt;
    cout << cnt << endl;
    for(int i = 1; i <= n; ++i) cout << v[i] << w[i] << endl;
```

