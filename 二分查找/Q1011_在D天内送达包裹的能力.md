传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。

传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。

返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。



```
输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5
输出：15
解释：
船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
第 1 天：1, 2, 3, 4, 5
第 2 天：6, 7
第 3 天：8
第 4 天：9
第 5 天：10

请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 
```



<b>思路：二分查找+贪心</b>

存在能在 D 天内将传送带上的所有包裹送达的船的最低运载能力$x_{ans}$ ，那么对于任意 运载能力$x$ ，一定有：

当$ x < x_{ans} $ ，在D天内无法送达所有包裹，当$ x >= x_{ans}  $ ，一定可以在D天内送达所有包裹。因此我们只需要遍历所有的$ x $ ，寻找到最低运载能力$x_{ans}$ ，那么如何判断$ x $ 能够在D天内送完所有包裹呢？我们可以使用贪心策略：

​	顺序选取包裹，当当前重量和大于$x$ ，那么我们需要去掉最后一个包裹，把它放到第二天送达。当所有包裹选取完毕且天数小于等于D，则满足条件。

​	接下来确认枚举的$x$ 的区间范围，对于左区间，由于包裹的完整性，每天至少应当有一个包裹，因此$x$ 的最小值应当为单个最大包裹的重量，右区间，最大$x$ 不会超过所有包裹的重量和。

​	在枚举$ x $ 时，我们可以使用二分查找的方法，当当前$x$ 可以在D天内送达，则我们在它的左区间继续寻找，否则到右区间寻找，二分查找结束位置就是我们所求的最低运载能力$x_{ans}$ 。 

```c++
int shipWithinDays(vector<int>& weights, int D) {
        int l = 0,r = 0;
        bool flag =false;
        for(auto w:weights){
            r += w;
            l = max(l,w);
        }
        
        while(l <= r){
            int mid = (l+r)>>1;
            if(canShipWithinDays(weights,D,mid)) r = mid-1;
            else l = mid+1;
        }

        return l;
    }

    bool canShipWithinDays(vector<int>& weights, int D,int x){
        int sum = 0,days = 1;

        for(auto w : weights){
            sum += w;
            if(sum > x){
                sum = w;
                days++;
            }
        }
        return days <= D;
    }
```

<b>复杂度分析</b>

时间复杂度：$O(nlogn)$ 。

空间复杂度：O(1)。

