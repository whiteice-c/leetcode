给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。



```
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```



<b>思路一：回溯+求余</b>

根据题意，若某个数字组合能够翻译为字符，那么数字范围应该在 0 - 25,具体的，给定一个大数，我们可以不断的获取最后1位和2位来判断是否能够合法翻译，若能则去掉后1位或2位，继续判断剩余整数。我们可以对整个数字进行不断的求余来判断当前的余数是否能合法翻译，显然，这是一个递归回溯问题。具体流程为：

- 对当前数字对$i(i = (10，100))$求余，判断余数是否可翻译，若可以，则继续判断 $ num/i $ ，若不可以翻译，则直接返回。
- 递归停止条件为 $ num = 0 $ 。



<b>特殊情况：</b>

- 当数字剩下最后一位时，此时应该只对10求余，对100求余是多余的。
- 像数字 506这种，可以发现第一次对 10 和 100求余时，结果是一样的，原因是后两位是06,因此对100求余时我们应当加上判断条件 $ num\%10 \neq num \% 100 $ 。

```c++
int translateNum(int num) {
        int ans = 0;
        backtrack(num,ans);
        return ans;
    }

    void backtrack(int num, int &ans){
        if(num == 0){
            ans++;
            return;
        }

        if(num%10 <= 25){
            backtrack(num/10,ans);
        }

        if( num%100 != num%10 && num%100 <= 25 && num > 9){
            backtrack(num/100,ans);
        }

    }
```



<b>思路二：动态规划</b>

根据思路一我们同样可以用动态规划来解决该问题，设$ dp[i] $ 表示前i个字符可以翻译的方案总数，对于前i个字符有：

- $ num[i] $ 一定能翻译为合理字符，其对整个方案数的贡献是$ dp[i] = dp[i-1] $
- 若 $ num[i-1,i] $  构成的两位字符在 0-25 之间，那么其对整个方案数的贡献是$ dp[i] +=  dp[i-2] $

```c++
int translateNum(int num) {
        int ans = 0;
        
        string nums = to_string(num);
        int n = nums.size();
        if (n <= 1) return 1;

        vector<int> dp(n+1);

        dp[0] = 1,dp[1] = 1;
        for (int i = 1; i < n; i++){
            dp[i+1] = dp[i];
            string tmp = nums.substr(i-1,2);
            if( tmp >= "10" && tmp <= "25"){
                dp[i+1] += dp[i-1];
            }
        }
    
        return dp[n];
    }
```

