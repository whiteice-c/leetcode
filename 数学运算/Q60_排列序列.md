给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

```
"123"
"132"
"213"
"231"
"312"
"321"
```


给定 n 和 k，返回第 k 个排列。



```
输入：n = 3, k = 3
输出："213"
```



```
输入：n = 4, k = 9
输出："2314"
```



思路：数学

对于数字1-n的全排列共有$n!$ 种，而从小到大的全排列有如下特点：

数字1为开头的，全排列共有$ (n-1)! $ 种。

数字2为开头的，全排列共有$ (n-1)! $ 种。

.....

数字n为开头的，全排列共有$ (n-1)! $ 种。



根据上面的特点，我们可以根据给定k来确定第一位数字是数字1-n中的第几位：
$$
order = \frac{k-1}{(n-1)!} +1
$$
即第k大的全排列，第一位为 $order$ ，而第一位为order的全排列共有 $(n-1)!$ 种，其区间在$[(order-1)*(n-1)! , order(n-1)! ]$ 

```
  1        2      3     ... ... order   ...   n 
(n-1)!	(n-1)!	(n-1)!	...	...	(n-1)!	... (n-1)!
```

继续确定第二位时，我们需要找到order对应的$(n-1)!$ 个全排列中的第 k' 大的，k'恰好是求解第一位序号时的余数，有
$$
k' = (k-1) mod (n-1)! +1
$$
此时我们变为了从小1位的全序列集合中寻找第 k'大的全排列，化解成了更小的问题。当我们确定第n位数字时即为所求。

<b>注意点:</b>

1. 当我们确定第i位时，剩余$ n-i+1$个数字未选择，order为：

$$
order = \frac{k-1}{(n-i)!} +1
$$

2. 确定order序号后，我们需要从未被选择的数字中选择第order大的，因此我们需要一个辅助数组来标记每个数字的使用情况，被使用过的则不会被考虑。

```go
func getPermutation(n int, k int) string {
    factorial := make([]int,n+1)

    factorial[0] = 1
    for i:=1; i <= n; i++{
        factorial[i] = factorial[i-1]*i //预计算阶乘
    }
    k--

    valid := make([]int,n+1)	//用于表示1-n数字的使用情况
    for i,_ := range valid{
        valid[i] = 1
    }

    ans := ""

    for i := 1; i <= n; i++{
        order := k/factorial[n-i]+1 //确定当前位置的数字序号
        for j := 1; j <= n; j++{
            order -= valid[j]	//从未使用的数字中确定对应序号的数字
            if order == 0{
                valid[j] = 0
                ans += strconv.Itoa(j)
                break
            }
        }
        k %= factorial[n-i]  //转化为求解子问题的k'
    }

    return ans
}
```

