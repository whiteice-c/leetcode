给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

**说明:** 你算法的时间复杂度应为 *O*(log *n*) 。



<b>方法一：</b>

返回阶乘结果中0的个数，首先考虑，在1-9中，能够使结果中有0的因子是 2,5,因此，给定任意一个整数，它的阶乘结果中0的个数可以看作含有多少对[2,5]这样的因子。因此，我们可以遍历n以内的数字，查询它们的因子是否包含2或5,并对他们计数，最终2,5个数中较少的数值就是结果中0的个数。

<b>note：</b>

1. 由于任意范围内，含有因子2的个数远远超过5,因此我们可以直接求含有5的因子个数即可。

2. 求解时不单单判断能否将5整除，还应该判断整除后结果是否能够继续将5整除，因为有的数字不止含有1个5因子，例如25.

3. 能够将5整除的数字一定是5的倍数，因此我们可以将步进改为5遍历整数。

```c++
int trailingZeroes(int n) {
        int count = 0;

        for(int i = 5 ; i <= n; i+= 5){
            int num = i;
            while( num % 5 == 0  ){
                count += 1;
                num /= 5;
            }
        }

        return count;
    }
```

<b>复杂度分析：</b>

时间复杂度：$ O(n) $  



<b>优化:</b>上面的方法依旧没有达到 $ O(\log n) $ 的时间复杂度，由于我们依旧要遍历 $ n/5 $ 个元素，且要检查每个元素含有多少个因子。现在，我们想办法来解决如何更快的获得每个数有多少个因子。 我们可以观察到，所有包含两个因子5的数都是25的倍数，且用25乘5的个数就是其含有因子5的个数，例如25有2个，25*5 = 125有3个 ... ，$  25 *n = 25n$ 含有n个因子5.

且我们发现，我们步进为5遍历的次数就是$ count = n/5 $ , 代表所有为5的倍数的数字个数，且若每个数字只含有1个因子5,那么因子5的总个数就是count。但上面我们提及若该数字还是25*n的倍数，那么他们对应还会多 n-1个因子，因此我们还需要计算 $ \frac{n}{5},\frac{n}{25},\frac{n}{125},\cdots,\frac{n}{25a} $ 的个数，即分别为 25,125 ，... ，25a倍数的数字的个数，然后累加即为数字n含有的所有因子5的个数。

注意： 是 25的倍数一定是5的倍数，也就是说虽然是25倍数的数字虽然有两个因子，但是我们在计算是5的倍数的数字时已经包含了25倍数的数字一次，因此我们得到的是25倍数的数字个数后无需将因子个数乘2,直接累加即可。同理，后续更大的倍数也直接累加即可（倍数增大1倍，因子数多1个）。

```c++
int trailingZeroes(int n) {
        int count = 0,pow_5 = 5;
        
        while( n >= pow_5 ){
            count += n / pow_5;
            pow_5 *= 5;
        }
        return count;
    }
```

<b>复杂度分析：</b>

时间复杂度：$ O(k) = O(\log n) $ . $ 5^k = n  \implies k = log_5n$ 

空间复杂度： $ O(1) $   

