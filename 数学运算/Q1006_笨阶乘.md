通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。

相反，我们设计了一个笨阶乘 clumsy：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。

例如，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。

另外，我们使用的除法是地板除法（floor division），所以 10 * 9 / 8 等于 11。这保证结果是一个整数。

实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。



```
输入：4
输出：7
解释：7 = 4 * 3 / 2 + 1
```



<b>思路一：</b> 模拟，状态转换

观察计算公式，我们可以发现运算规律：先去掉第一个运算符循环乘除加减，从第二个乘除加减开始，由于减法后为乘除，因此我们需要先计算乘除，然后用符号$'-'$之前的结果减去乘除后的结果，然后再加下一位数字。即 $ ans[i] - (num1*num2/num3) + num4 $ 构成一次循环。其中$ ans[i] $ 为上一次循环计算的结果，即每次循环需要计算$(num1*num2/num3) + num4$。 

我们可以用一个变量记录下一次运算的状态，循环上面的运算顺序。另外初始时的一次循环得到的结果应当作为正数，其前面没有减号，之后的循环结果都应当充当上一次循环结果的减数。

另外还需注意遍历结束时，未完成完整的一次循环，我们需要根据循环状态处理掉最后的部分。

```c++
int clumsy(int N) {
        if(N == 1) return 1;

        int state = 0;
        long ans = 0 ,num = 1 ;
        bool flag = true;

        N--;
        while( N > 0){
            if( state == 0 ){
                num = N*(N+1);
                state = 1;
            }
            else if( state == 1 ){
                num /= N;
                state = 2;
            }
            else{
                if(flag){ //初始乘除为正数，之后都为减数
                    ans = num+N;
                    flag = false;
                }
                else ans = ans - num + N;              
                state = 0;
                N--;
                if( N == 1 ) return ans-1; //剩余最后1位数字，直接返回
            }
            N--;
        }

        if( state > 0 ) flag ? ans += num : ans -= num;

        return ans;
    }
```

  <b>复杂度分析：</b>

时间复杂度：$ O(n) $ 。  

空间复杂度：$ O(1) $  。



<b>思路二：栈 </b>

我们通过栈来计算等式，遇到乘除法时，我们直接运算，并将结果压入栈中，由于加法后面一定是减法，因此我们也一样可以直接计算加法，遇到剑法则将当前数的负数压入栈中，先不计算。遍历结束后栈中全部为加法运算，计算即可。

```c++
int clumsy(int N) {
        long ans = 0;
        int stage = 0;
        stack<int> stk;

        stk.push(N);
        while(--N){
            switch(stage){
                case 0:
                    stk.top() *= N;
                    stage = 1;
                    break;
                case 1:
                    stk.top() /= N;
                    stage = 2;
                    break;
                case 2:
                    stk.top() += N;
                    stage = 3;
                    break;
                default:
                    stk.push(0-N);
                    stage = 0;
            }
        }

        while(!stk.empty()){
            ans += stk.top();
            stk.pop();
        }

        return ans;
    }
```

 <b>复杂度分析：</b>

时间复杂度：$ O(n) $ 。  

空间复杂度：$ O(n) $  。 



<b>思路三：数学</b>

我们观察笨阶乘的一些运算式：

<p>

$$
5×4/3 = 6 \\
6×5/4 = 7 \\
7×6/5 = 8 \\
$$
</p>

一般的，

<p>

$$
\begin{align}
& \frac{n\cdot (n-1)}{n-2} \\
= & \frac{n^2-n}{n-2} \\
= & \frac{n^2-2n+n}{n-2} \\
= & \frac{n\cdot(n-2)+n}{n-2} \\
= & n+\frac{n}{n-2} \\
= & n+\frac{n-2+2}{n-2} \\
= & n+1+\frac{2}{n-2} \\

\end{align}
$$
</p>

对于$ \frac{2}{n-2} $ ，当 $ n-2 < 2 $ 即 $ n > 4 $ 时，结果为0,因此有 

<p>

$$
\frac{n\cdot (n-1)}{n-2} = n+1   \ \ \ \ if \ n > 4
$$
</p>

再观察笨阶乘的其中一部分：

<p>

$$
clumsy(n) = n*(n-1)/(n-2)+(n-3)-(n-4)*(n-5)/(n-6)+(n-7)-\cdots
$$
</p>

可以发现 $ -(n-4)*(n-5)/(n-6)+(n-7) = 0 $ ,可以直接消去。

对于任意数字的笨阶乘，都是4次一循环，且满足加减乘除的顺序，再结合我们上面可以消去的分析，因此我们可以将整个笨阶乘尽可能的消去，剩下最少子式。我们将$ n $ 对4求余，然后根据余数情况进行讨论：

<p>

1.  $ mod = 0 $ ,观察展开式可以发现除去前三项和后5项，其他部分都可以消去。

$$
\begin{align}
clumsy(n) =& n*(n-1)/(n-2)+(n-3)-\cdots 8*7/6+5-4*3/2+1 \\
=& n*(n-1)/(n-2)+(n-3)+ 0 + 5-4*3/2+1 \\
=& n+1

\end{align}
$$

2.  $ mod = 1 $ , 除了前三项和后6项，其他部分都可以消去。

$$
\begin{align}
clumsy(n) =& n*(n-1)/(n-2)+(n-3)-\cdots 10*9/8+7-6*5/4+3-2*1 \\
=& n+1+0+6-6+2-1 \\
=& n+2

\end{align}
$$

3. 同理，$ mod = 2 $ , 除了前三项和后7项，其他部分都可以消去。

$$
clumsy(n) = n+2
$$

4. 同理，$ mod = 3 $ , 除了前三项和后8项，其他部分都可以消去。

$$
clumsy(n) = n-1
$$



</p>

另外，当N<4时，我们可以单独计算笨阶乘即可。

```c++
int clumsy(int N) {
        if(N == 1) return 1;
        else if(N == 2) return 2;
        else if(N == 3) return 6;
        else if(N == 4) return 6;

        if( N%4 == 0 ) return N+1;
        else if( N%4 <= 1 ) return N+2;
        else return N-1;
    }
```

 <b>复杂度分析：</b>

时间复杂度：$ O(1) $ 。  

空间复杂度：$ O(1) $  。 