给定一个正整数，返回它在 Excel 表中相对应的列名称。

```
    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
```



方法一（进制转换）：

题目类似与进制转换，将10进制数值转化为26进制表示，正常转换公式为：
$$
n = x_n*26^{n-1} + \cdots +  x_2*26^1 + x_1*26^0 \\
x_1,x_2,\cdots,x_n \in [0,25]
$$
其求解每一位的数值方式可以通过求余求模操作求解。
$$
\begin{align}
&n = x_n*26^{n-1} + \cdots +  x_2*26^1 + x_1*26^0 \implies n \% 26 = x_1 \\
&求解x_2 : \\
&1.求模去掉x_1: n = n/26 = x_n*26^{n-2} + \cdots +  x_2*26^0  \\
&2.求余求解x_2: n \% 26 = x_2
\end{align}
$$
对于一般的数字，我们可以直接用公式转换，例如：
$$
27 = 1*26^1 + 1*26^0  \implies 1,1 \implies AA \\
$$
但是，存在一些特殊数值，其表示方式与上述公式并不相同：
$$
公式表示： 52 =  2*26^1 + 0*26^0  \implies 2,0 \implies BZ \\
按题目要求： 52 = 1*26^1 + 26  \implies AZ \\
\\
公式表示： 702 =  1*26^2 + 1*26^1 + 0*26^0  \implies AAZ \\
按题目要求： 702 =  26*26^1 + 26  \implies ZZ \\
$$
可以看到，对于那些求余为0的数字，表示方式并不相同。原因是题目每一位的表示范围是[1,26],而在转换公式中范围为[0,25]。虽然我们在上面遇到0时已经将其转化为26,但表示方式依旧不同。原因是当我们将 $ 0*26^i $  转换为 $ 26*26^i $ 的时候，此时我们再求解下一位的数值时，我们的求模去掉当前求解位数值的操作将失效：
$$
\begin{align}
&设： 52 =  x_n*26^{n-1} + \cdots + x_1*26^0 \\
&求解x_1 :\\
&52 \% 26 = 0 \implies x_1 = 0 \implies x_1 = 26 \\
&\implies 52 =  x_n*26^{n-1} + \cdots + 26\\
&求解x_2 :\\
&1.求模去掉x_1:  52 / 26 =  x_n*26^{n-1} + \cdots + x_2*26^1 + 1
\end{align}
$$
可以看出，在遇到求余为0修改为26后，再去求解下一位数值，求模并未将$ x_1 $ 去掉，而是变为了1,因此，我们在该情况下需要将数值减1再进行下一步操作即可。

```c++
string convertToTitle(int n) {
    string ans = "";

    while(n>0){
        int t = n % 26;
        if( t == 0 ){
            t = 26;   //将对应位变为0,并将原数减1
            n -= 1;
        }
        ans +=  'A' + t -1;
        n /= 26; 
    }
    reverse(ans.begin(),ans.end());
    return ans;
}
```

  **复杂度分析：**

时间复杂度：$ O(\sqrt[26]{n}) $ 

空间复杂度： $ O(1) $   

