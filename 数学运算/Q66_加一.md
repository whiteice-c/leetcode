给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```



思路一：

​	常规解法就是从后往前遍历加一后的数，若当前数没有大于10,则说明该数无需进位，我们可以直接返回结果;若当前结果大于10,则我们需要按照进位规则，前一位加一，当前位变为0（因为原始数字每一位最高为9）。但还需注意的一点是像999这样的数字，进位后会导致数字位数增加，因此我们需要在循环中判断前一位是否存在，若不存在且需要进位加一，我们在当前位的前面插入1即可。

```c++
vector<int> plusOne(vector<int>& digits) {
        digits[digits.size()-1] += 1;

        for(int i = digits.size()-1; i >= 0 ; --i){
            if(digits[i] >= 10){
                if(i-1 < 0){
                    digits.insert(digits.begin(),1);
                    digits[i+1] = 0;
                }
                else{
                    digits[i-1] += 1;
                    digits[i] = 0;
                }
                continue;
            }
            break;
        }
        return digits;
    }
```



**复杂度分析：**

时间复杂度分析：$ 0(n) $ ,最多需要遍历一遍整个数组

空间复杂度分析：$ O(1) $  



思路二：

​		我们可以在循环中对每一位加一后再对10求余，这样只有等于0才说明需要进位。这里利用了题目条件，因为数字只加一，因此不会出现某一位 8 + 9 = 17这样的进位，在每一位上，仅仅会出现9+1这样的进位，因此我们无需关心进位加一到前一位这一规则，只需关心每一位是否需要进位即可，若不需要进位，则可以直接返回结果。特别的，对于999这种会使结果位变长的，我们只需要在循环结束后判断即可，若能够执行到这里，则出现了位数变长的现象，我们直接生成新vector并将首位置为1即可。

```c++
for(int i = digits.size()-1; i >= 0 ; --i){
            digits[i] += 1;
            digits[i] %= 10;
            if(digits[i] != 0) return digits;  //=0才说明需要进位
        }

        digits = vector<int>(digits.size()+1,0);
        digits[0] = 1;

        return digits;
```

**复杂度分析：**

时间复杂度：$ O(n) $ 

空间复杂度：$ O(1) $ 

