森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 answers 数组里。

返回森林中兔子的最少数量。



```
示例:
输入: answers = [1, 1, 2]
输出: 5
解释:
两只回答了 "1" 的兔子可能有相同的颜色，设为红色。
之后回答了 "2" 的兔子不会是红色，否则他们的回答会相互矛盾。
设回答了 "2" 的兔子为蓝色。
此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。
因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。

输入: answers = [10, 10, 10]
输出: 11

输入: answers = []
输出: 0
```

1. `answers` 的长度最大为`1000`。
2. `answers[i]` 是在 `[0, 999]` 范围内的整数。



思路一：贪心算法+map

若出现数字$num$，那么至少共有$num+1$只该颜色的兔子，因此我们可以遍历给定数组，用map存储出现相同数字的次数，若出现次数等于$ num+1 $ ,说明已满足该颜色的最少数量的兔子，我们将其数量加入到最终结果之中，并将map对应num保存的次数变为0，若再次出现该数字，则表明是新的颜色。遍历结束后，我们还需要检查map中次数不为0的key，将其对应的最少数量$ key+1 $ 加入到结果即可。

```c++
int numRabbits(vector<int>& answers) {
        int n = answers.size(),ans = 0;
        unordered_map<int,int> m;

        for( auto num : answers ){
            if( num == 0 ) ans++;
            else if( m[num] == num ){
                m[num] = 0;
                ans += num+1;
            } 
            else m[num]++; 
        }

        for( auto [key,val] : m ){
            if( val != 0 ) ans += key+1;
        }
        return ans;
    }
```

<b>复杂度分析：</b>

时间复杂度：$ O(mn) $

空间复杂度：$O(mn) $ 