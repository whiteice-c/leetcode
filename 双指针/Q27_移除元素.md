给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。



```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```



<b>方法一：同向双指针</b>
<b>思路:</b> 

既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(1)的额外空间来处理它。如何解决？我们可以保留两个指针 i 和 j，其中 i是慢指针，j 是快指针。

<b>算法:</b>

当 nums[j] 与给定的值相等时，递增 j 以跳过该元素。只要 $nums[j] \neq val$，我们就复制 nums[j] 到 nums[i] 并同时递增两个索引。重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i

```c++
int removeElement(vector<int>& nums, int val) {

        int len = nums.size();

        int i = 0;
        for(int j = 0 ;j < len; ++j){
            if(nums[j] != val){
                nums[i++] = nums[j];
            }
        }
        return i;
    }
```



<b>复杂度分析</b>

- 时间复杂度：O(n)，
  假设数组总共有 n个元素，i和 j至少遍历 2n 步。
- 空间复杂度：O(1)。

缺点：当数据类似于 $ nums = [4,1,2,3,5] ,val = 4$ 时，会做四次不必要的赋值左移操作。



<b>方法二：相向双指针</b> 

算法：我们同样使用两个指针，不过让他们分别指向首尾，特殊的是，我们可以直接利用len作为尾部指针，首先首部指针顺序遍历，当有 $ nums[i] == val $ 时，我们就开始使用尾部指针，判断尾部指针所指元素的值是否不等于val ， 即 $  nums[i] \neq val $ ,若满足，我们直接替换掉首指针中的值并继续向后遍历;若尾指针指向的值也与val相同，我们则将尾指针向前遍历，直到遇到不相等的进行复制，特别的，当尾指针移动过程中与首指针相遇时，说明遍历提前结束，直接返回尾指针即可。 

```c++
int removeElement(vector<int>& nums, int val) {

        int len = nums.size();

        for(int i = 0 ;i < len; ++i){
            if(nums[i] == val){
                while(nums[--len] == val){
                    if(len == i)
                        return len;
                }
                nums[i] = nums[len];
            }
        }
        return len;
    }
```

<b>复杂度分析</b>

- 时间复杂度：$O(n)$ 
  i和len最多遍历n步，赋值操作的次数等于要删除元素的数量。因此，如果要移除的元素很少，效率会更高。
- 空间复杂度：$O(1)$。 