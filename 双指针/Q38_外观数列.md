思路：

​	使用双指针的方法，每次用尾指针遍历当前的数字字符串，若尾指针指向的字符串与首指针指向的相同，则不做操作;直到不同，则记录即描述当前相同的字符串（如3个1  == 111 == 31），描述完毕后把尾指针指向的值赋值给首指针，尾指针继续向后遍历直到循环结束。循环结束还应当描述一次，因为不论最后一部分数字字符串是否相同，末尾的还没有被描述。

```c++
string countAndSay(int n) {
        string oldstr = "1";
        string ans = "";

        int len = oldstr.length();
        int i = 0;

        if(n == 1)
            return "1";

        while(n-1){
            i = 0;
            len = oldstr.length();
            for(int j = 0; j < len; ++j){
                if(oldstr[i] != oldstr[j]){
                    ans += to_string(j-i);
                    ans += oldstr[i];
                    i = j;
                }
            }
            ans += to_string(len-i);
            ans += oldstr[i];

            oldstr = ans;
            ans = "";
            --n;
        }

        return oldstr;
    }

```

**复杂度分析：**

时间复杂度：$O(mn)$ ,其中m为外观数列的第m项所需要的循环次数，n为每次计算第m项所需要的循环次数。

空间复杂度：O(1)