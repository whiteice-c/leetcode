给定一个正整数 n ，输出外观数列的第 n 项。

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列：

countAndSay(1) = "1"
countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。
前五项如下：

```
1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
```

思路：

​	使用双指针的方法，每次用尾指针遍历当前的数字字符串，若尾指针指向的字符串与首指针指向的相同，则不做操作;直到不同，则记录即描述当前相同的字符串（如3个1  == 111 == 31），描述完毕后把尾指针指向的值赋值给首指针，尾指针继续向后遍历直到循环结束。循环结束还应当描述一次，因为不论最后一部分数字字符串是否相同，末尾的还没有被描述。

```c++
string countAndSay(int n) {
        string oldstr = "1";
        string ans = "";

        int len = oldstr.length();
        int i = 0;

        if(n == 1)
            return "1";

        while(n-1){
            i = 0;
            len = oldstr.length();
            for(int j = 0; j < len; ++j){
                if(oldstr[i] != oldstr[j]){
                    ans += to_string(j-i);
                    ans += oldstr[i];
                    i = j;
                }
            }
            ans += to_string(len-i);
            ans += oldstr[i];

            oldstr = ans;
            ans = "";
            --n;
        }

        return oldstr;
    }

```

**复杂度分析：**

时间复杂度：$O(mn)$ ,其中m为外观数列的第m项所需要的循环次数，n为每次计算第m项所需要的循环次数。

空间复杂度：O(1)