给定一个字符串 S，找出 S 中不同的非空回文子序列个数，并返回该数字与 $10^9 + 7 $的模。

通过从 S 中删除 0 个或多个字符来获得子序列。

如果一个字符序列与它反转后的字符序列一致，那么它是回文字符序列。

如果对于某个  i，$A_i != B_i$，那么 $A_1, A_2, ...$ 和 $B_1, B_2, ...$ 这两个字符序列是不同的。



```
输入：
S = 'bccb'
输出：6
解释：
6 个不同的非空回文子字符序列分别为：'b', 'c', 'bb', 'cc', 'bcb', 'bccb'。
注意：'bcb' 虽然出现两次但仅计数一次。
```



<b>动态规划</b>

我们设$ dp[i][j] $ 表示字符串s的子区间 $s[i...j]$ 拥有的不同的非空回文子序列个数，现在我们考虑动态转移方程，这里假设我们在求解$ s[i...j] $ 的非空回文子序列时，$  s[i...j] $ 的子区间的非空回文子序列个数我们都已经求解。那么有（注意子序列是可以间隔选取，不必要连续）：

1. 若$ s[i] = s[j] $ ,那么有$ dp[i][j] = 2*dp[i+1][j-1]+2 $ 。

   1. 其中一个$ dp[i+1][j-1] $ 是$s[i+1，...，j-1] $ 拥有的非空回文子序列个数，另一个$  dp[i+1][j-1]  $ 是$s[i+1，...，j-1] $ 的每一个非空回文子序列在两边加上$ s[i],s[j] $ 构成的新的非空回文子序列的个数。
   2. 加2是由$s[i]$ 和$ s[j]$ 构成的回文子串，由于相当，因此可以构成两个回文子串 $(eg: aa -> a, aa)$

```
s    0  1  2  3  4  5
     d  b  a  b  d  a
求解 dp[0][4],之前的dp[i][j]（i > 0 , j < 4）都已求解
dp[0][4] = 2*dp[1][3] + 2
一个dp[1][3] ==> s[1,..,3]=bab ==> a, b, bb, bab
另一个dp[1][3] ==> s[0,..,4]=dbabd ==> dad, dbd, dbbd, dbabd (上面的基础上两边加d)
加2 ==> s[0]+s[4] = dd ==>  d, dd 两个回文字串 
```



2. 此外，我们还需要考虑在子区间$ s[i+1,j-1] $ 中，是否含有与$ s[i] $ 相同的元素，相同元素会导致出现一些重复的回文子串：
   1. 若含有1个相同的元素，那么在上面的加2里的单元素回文子串一定在子区间里出现过，因此我们需要去掉，有 $ dp[i][j] = 2*dp[i+1][j-1]+1 $ 。
   2. 若含有大于等于2个的相同元素，那么我们需要从子区间 $s[i+1,j-1] $ 找到最左和最右的相同元素位置$l,r$ ，那么$ s[l+1,r-1] $ 中的所有非空回文子串加上两边元素$ s[l],s[r] $ 与加上两边元素$ s[i],s[j] $ 具有相同的回文子串，因此我们需要把这一部分去掉,上面的情况1已经讨论，$s[l+1][r-1]$ 加上两边元素$s[l],s[r]$ 的回文子串个数应该为$ dp[l+1][r-1] $。因此最后有$  dp[i][j] = 2*dp[i+1][j-1]-dp[l+1][r-1]+2  $ 。这里加2保留因为 $ dp[l][r] $ 中以计算但是我们去掉了。

3. 若$  s[i] \neq s[j]  $ ，那么就不能同时在 $ s[i+1,j-1] $ 的两侧添加$ s[i],s[j] $ 来求解$ dp[i][j] $ ，我们需要分别添加然后去计算，即分别求解$dp[i,j-1]$ 和 $ dp[i+1,j] $ ,可以注意到分别求解的两个子区间也存在公共部分$ s[i+1,j-1] $ ，我们也要在求解后去掉这个重叠区域，因此有$  dp[i][j] = dp[i][j-1]+dp[i+1][j]-dp[i+1][j-1]  $ 。

最终有：

<p>

$$
dp[i][j] = 
\begin{cases}
  2*dp[i+1][j-1]+2  & if(s[i] = s[j]  & and & s[l]\neq s[r] \neq s[i])  \\
  2*dp[i+1][j-1]+1  & if(s[i] = s[j]  & and & s[l]  = s[i])  \\
  2*dp[i+1][j-1]-dp[l+1][r-1]+2   &  if(s[i] = s[j]  & and & s[l] =s[r] = s[i])\\
  dp[i][j-1]+dp[i+1][j]-dp[i+1][j-1]  & if(s[i] \neq s[j])
\end{cases}
$$

</p>

```c++
int countPalindromicSubsequences(string S) {
        int n = S.size();
        const int mod = 1000000007;
        vector<vector<long>> dp(n,vector<long>(n));

        for(int i = 0 ; i < n; ++i) dp[i][i] = 1; //初始化
		
        for(int j = 0 ; j < n ; ++j){
            for(int i = n-1 ; i >= 0 ; --i){
                if( i >= j ) continue;
                if( S[i] != S[j] ) //情况3
                    dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1];
                else{
                    dp[i][j] = 2*dp[i+1][j-1] + 2; //情况1
                    int l = i+1,r = j-1;
                    while( l <= r && S[l] != S[i]) l++;
                    while( l <= r && S[r] != S[i]) r--;
                    if( l == r ) dp[i][j]--; //情况2-1
                    else if( l < r ) dp[i][j] -= dp[l+1][r-1]+2;//情况2-2
                }
                dp[i][j] = dp[i][j] >= 0 ? dp[i][j]%mod : dp[i][j]+mod; //因为mod的原因导致有些dp[i][j] < dp[l+1][r-1] , 此时应当让 dp[i][j]+mod 再减去dp[l+1][r-1]
            }
        }
        return dp[0][n-1];
    }
```

<b>复杂度分析：</b>

时间复杂度：$ O(n^2) $

空间复杂度：$O(n^2) $ 

循环优化部分：（自顶向下动态更新）

```c++
for(int i=n-2;i>=0;i--)
   for(int j=i+1;j<n;j++)
```

