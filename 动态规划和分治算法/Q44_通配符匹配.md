给定一个字符串 (`s`) 和一个字符模式 (`p`) ，实现一个支持 `'?'` 和 `'*'` 的通配符匹配。

```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
```

两个字符串完全匹配才算匹配成功。

说明:

- s 可能为空，且只包含从 a-z 的小写字母。
- p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。



```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```



<b>动态规划</b>

该问题与Q10_正则表达式匹配问题类似，也是字符串匹配问题。我们设$  dp[i][j] $ 表示 s的前i个字符与p的前j个字符匹配的情况。现在我们来分析动态转移方程：

+ 当$ s[i] == p[j] $ 或是$ p[j] = '?'$ 时，那么当前遍历的字符匹配，因此$dp[i][j] = dp[i-1][j-1]$ ，即此时若他们之前的字符匹配，加入$s[i],p[j]$后依旧匹配。

+ 若$ p[j] = '*' $ 时，由于 它可以匹配0或多个任意字符，因此我们需要考虑是否用$ p[j] $ 匹配$ s[i] $ ：
  + 若选择匹配，那么考虑上一个匹配字符对，有可能为$ s[i-1],p[j] $ ，即上一个字符也使用$p[j] $ 匹配，也有可能为$ s[i-1],p[j-1] $ ， 即上一个字符未使用$p[j] $ 匹配。因此有$ dp[i][j] = dp[i-1][j-1] | dp[i-1][j] $ 。且我们可以发现，在分析$ dp[i-1][j] $ 时，我们其实已经分析了$ s[i-1],p[j-1] $ 的情况，因此最终有$  dp[i][j] =  dp[i-1][j]  $。

+ 若不选择匹配，$ dp[i][j] = dp[i][j-1] $。即若$s[0..i]$ 与$ p[0..j-1] $  匹配，则$s[0..i]$ 与$ p[0..j] $  匹配 。

最终状态转移方程为：

<p>

$$
dp[i][j] = 
\begin{cases}
dp[i-1][j-1] & s[i]=s[j] \ \ or \ \ p[j] = '?' \\
dp[i-1][j]\  | \ dp[i][j-1]  & p[j] = '*'
\end{cases}
$$

</p>

<b>边界情况考虑：</b>

- 初始时$ dp[0][0] = 1$ ，即空字符串互相匹配。
- $dp[i][0] = 0 , i >= 1$，模式串为空无法与非空串匹配。 
- $dp[0][i] = 1 , if\ p[0..i] = '*'$ ,模式串前i个字符全为*，则可以匹配空串。

```c++
bool isMatch(string s, string p) {
        int m = s.size(),n = p.size();

        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        dp[0][0] = 1;
        for(int i = 1; i <= n; ++i){
            if(p[i-1] == '*') dp[0][i] = 1;
            else break;
        }

        for(int i = 1; i <= m; ++i){
            for(int j = 1; j <= n; ++j){
                if( s[i-1] == p[j-1] || p[j-1] == '?' )
                    dp[i][j] |= dp[i-1][j-1];
                else if( p[j-1] == '*' )
                    dp[i][j] = dp[i][j-1]  | dp[i-1][j];
            }
        }
        return dp[m][n];
    }
```

<b>复杂度分析</b>

时间复杂度：$ O(mn)$ 。

空间复杂度：$ O(mn)$ 。 

