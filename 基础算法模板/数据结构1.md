​	

单链表：



```c++
// head存储链表头(下标)，e[i]存储节点i的值，ne[i]存储节点i的next指针(下标)，idx表示当前可使用的创建节点位置(下标)
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0; //表示可以从0号点开始操作
}

// 在链表头插入一个数a     
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

//插入到某个节点下标k(第k个节点)之后
void insert(int a, int k){
    e[idx] = a, ne[idx] = ne[k], ne[k] = idx,idx++;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}

//删除k节点之后的一个元素,删除后也就是不考虑对应数组空间
void remove(int k){
    ne[k] = ne[ne[k]];
}
```

头插：

```
head      //head = -1 , idx = 0;
head -> node1;   //e[0] = val, ne[0] = head = -1 , head = idx = 0, idx = 1 ;
head -> node2 -> node1;  //e[e] = val, ne[1] = head = 1; head = idx = 1; idx = 2;
```



<b>双链表</b>

```c++
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前可使用的创建节点位置(下标)
int e[N], l[N], r[N], idx;

// 初始化
void init()
{
    //0是左端点，1是右端点 (边界节点，无实质内容)
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```



<b>栈</b>

```c++
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0) not empty
else empty
```



<b>队列</b>

```c++
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh <= tt) not empty
else empty
```



<b>循环队列</b>

```c++
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}
```



<b>单调栈</b>

常见模型：找出每个数左边离它最近的比它大/小的数

对于$ a1,a2,...,a_i,...,a_n $ ，若$ a_i < a_j ,且 i > j $ ，那么寻找$ a_i $ 之后的目标元素时，$ a_j $ 一定不会被选到，因此可以删除，我们维护这样一个单调栈。

```c++
常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], nums[i])) tt -- ; //维护一个单调上升的序列
    stk[ ++ tt] = nums[i];
}
```



<b>单调队列</b>

求取窗口内的最小值：每次移动窗口后，我们都需要遍历窗口内的所有元素，效率较低，若能够使队列中的元素具有单调上升的性质，那么队头元素即为当前窗口最小值。对于窗口大小为$ k $ 的队列，$ a_1,a_2,...,a_k $ ，窗口中若存在$ i <j 且 a_i > a_j  $ ，那么$a[i]$ 在其生命周期内一定不会是窗口内的最小值（比$ a[j] $ 小，且 $a[j]$ 生命周期长）。因此可以直接删去$ a[i] $ ，这样就保证了窗口内的元素单调递增。

```c++
常见模型：找出滑动窗口中的最大值/最小值
//q[] 保存队列下标 , k 为窗口大小
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && i-k+1 > q[hh]) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(nums[q[tt]], nums[i])) tt -- ; //从队尾开始找到新增元素的插入位置，保持单调
    q[ ++ tt] = nums[i]; //将新元素插入队尾
}
```



<b>KMP算法</b>

字符串s与模板串p匹配问题：

定义$ next[i] = j $ 为模板串中， $p[1...j]$ 与$p[i-j+1...i] $ 是相等的。即以i为终点的子串$p[i-j+1...i] $与以起点1开始的子串$p[1...j]$最长相同部分的长度为j。

```
1               i
a1 a2 a3 a4 ... ai ... an 
若 next[i] = 3  则有 [a1,a2,a3] = [a(i-2),a(i-1),ai]
```

这样，当字符串s与模板串p匹配过程中，若有$ s[i] \neq p[j] $ 时，我们可以求得$ next[i] $ 的长度 $k$ ，表示$p[1...k]$ 与 $s[i,i-k-1]$ 是相等的，我们不需要从头开始匹配，直接从比较$s[i+1]$ 和$p[k+1]$ 开始即可。 

求解next数组就是自身匹配的过程，若 $p[i] \neq p[j] $ ，则子串$ p[1,j] $ 回退，直到$ p[1,k] = p[i-k-1,i] $ ，此时有$ next[i] = k $ ，若$p[i] = p[j] $ ，则有$ p[1,j] = p[i-j-1,i] , next[i] = j $ 。

```c++
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度 
求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ ) //与自身匹配的过程
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// 匹配
for (int i = 1, j = 0; i <= n; i ++ )
{ 
    while (j && s[i] != p[j + 1]) j = ne[j]; //不匹配时，回退到next[j]处开始匹配，若 j = 0，说明需要开始从头匹配
    if (s[i] == p[j + 1]) j ++ ; //回退后，next[j]后的第一个字符匹配成功，或从头开始匹配成功
    if (j == m)
    {
        j = ne[j]; //匹配成功的下一次开始匹配位置
        // 匹配成功后的逻辑
    }
}
```

求解next数组代码过程：

```
 p = abababab
 1 2 3 4 5 6 7 8
 a b a b a b a b
 
 next[1] = 0  此时子串长度为0，无相同后缀前缀子串
 next[2] : p[2] neq [1], j = next[1] = 0, p[2] \neq p[1]  next[2] = j = 0
 next[3] : p[3] = p[1], j = 1 , next[3] = 1
 next[4] : p[4] = p[2], j = 2, next[4] = 2
 ...
```



<b>Trie树</b>

用于高效地存储和查找字符串集合的数据结构 

```c++
int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点，N为给定字符串的总长度
// cnt[]存储以每个节点结尾的单词数量
// idx用于计数创建节点，创建过程中为首次出现的字符节点分配不同的序列号

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx; //当前节点不存在该儿 子，创建
        p = son[p][u]; //更新父亲节点，准备记录下一节点
    }
    cnt[p] ++ ;//记录以该节点结尾的单词数量
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

