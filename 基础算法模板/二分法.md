​	

单链表：



```c++
// head存储链表头(下标)，e[i]存储节点i的值，ne[i]存储节点i的next指针(下标)，idx表示当前可使用的创建节点位置(下标)
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0; //表示可以从0号点开始操作
}

// 在链表头插入一个数a     
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

//插入到某个节点下标k(第k个节点)之后
void insert(int a, int k){
    e[idx] = a, ne[idx] = ne[k], ne[k] = idx,idx++;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}

//删除k节点之后的一个元素,删除后也就是不考虑对应数组空间
void remove(int k){
    ne[k] = ne[ne[k]];
}
```

头插：

```
head      //head = -1 , idx = 0;
head -> node1;   //e[0] = val, ne[0] = head = -1 , head = idx = 0, idx = 1 ;
head -> node2 -> node1;  //e[e] = val, ne[1] = head = 1; head = idx = 1; idx = 2;
```



<b>双链表</b>

```c++
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前可使用的创建节点位置(下标)
int e[N], l[N], r[N], idx;

// 初始化
void init()
{
    //0是左端点，1是右端点 (边界节点，无实质内容)
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```



<b>栈</b>

```c++
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0) not empty
else empty
```



<b>队列</b>

```c++
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh <= tt) not empty
else empty
```



<b>循环队列</b>

```c++
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}
```



<b>单调栈</b>

常见模型：找出每个数左边离它最近的比它大/小的数

对于$ a1,a2,...,a_i,...,a_n $ ，若$ a_i < a_j ,且 i > j $ ，那么寻找$ a_i $ 之后的目标元素时，$ a_j $ 一定不会被选到，因此可以删除，我们维护这样一个单调栈。

```c++
常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], nums[i])) tt -- ; //维护一个单调上升的序列
    stk[ ++ tt] = nums[i];
}
```



<b>单调队列</b>

求取窗口内的最小值：每次移动窗口后，我们都需要遍历窗口内的所有元素，效率较低，若能够使队列中的元素具有单调上升的性质，那么队头元素即为当前窗口最小值。对于窗口大小为$ k $ 的队列，$ a_1,a_2,...,a_k $ ，窗口中若存在$ i <j 且 a_i > a_j  $ ，那么$a[i]$ 在其生命周期内一定不会是窗口内的最小值（比$ a[j] $ 小，且 $a[j]$ 生命周期长）。因此可以直接删去$ a[i] $ ，这样就保证了窗口内的元素单调递增。

```c++
常见模型：找出滑动窗口中的最大值/最小值
//q[] 保存队列下标 , k 为窗口大小
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && i-k+1 > q[hh]) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(nums[q[tt]], nums[i])) tt -- ; //从队尾开始找到新增元素的插入位置，保持单调
    q[ ++ tt] = nums[i]; //将新元素插入队尾
}
```

